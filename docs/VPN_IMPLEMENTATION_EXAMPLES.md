# VPN Implementation Examples

This document provides concrete examples for implementing the VPN feature.

## Docker Compose Configuration

### docker-compose.prod.yml Addition

```yaml
services:
  # ... existing web service ...
  
  vpn-server:
    image: strongswan:latest
    container_name: aviationwx-vpn
    network_mode: host  # Required for IPsec
    cap_add:
      - NET_ADMIN
      - NET_RAW
    volumes:
      - ./vpn-config:/etc/ipsec.d:ro
      - ./vpn-secrets:/etc/ipsec.secrets:ro
      - ./vpn-manager:/usr/local/bin/vpn-manager:ro
    environment:
      - CONFIG_PATH=/var/www/html/airports.json
    restart: unless-stopped
    depends_on:
      - web
    healthcheck:
      test: ["CMD", "ipsec", "status"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  vpn-manager:
    build:
      context: ..
      dockerfile: docker/Dockerfile.vpn-manager
    container_name: aviationwx-vpn-manager
    network_mode: host
    cap_add:
      - NET_ADMIN
      - NET_RAW
    volumes:
      - ../config/airports.json:/var/www/html/config/airports.json:ro
      - ./vpn-config:/etc/ipsec.d
      - ./vpn-secrets:/etc/ipsec.secrets
    environment:
      - CONFIG_PATH=/var/www/html/config/airports.json
    # PSKs are read directly from airports.json (mounted as volume above)
    restart: unless-stopped
    depends_on:
      - vpn-server
```

## strongSwan Configuration Examples

### ipsec.conf (Generated by VPN Manager)

```conf
# strongSwan IPsec configuration
# Auto-generated from airports.json

config setup
    charondebug="ike 2, knl 2, cfg 2"
    uniqueids=never
    strictcrlpolicy=no

# Connection for KSPB airport
conn kspb_vpn
    type=tunnel
    auto=start
    keyexchange=ikev2
    ike=aes256gcm128-sha256-modp2048!
    esp=aes256gcm128-sha256-modp2048!
    left=%defaultroute
    leftid=@vpn.aviationwx.org
    leftsubnet=0.0.0.0/0
    leftauth=psk
    right=%any
    rightid=@kspb.remote
    rightsubnet=192.168.1.0/24
    rightauth=psk
    dpdaction=restart
    dpddelay=30s
    dpdtimeout=120s
    rekey=yes
    reauth=yes
    fragmentation=yes
    forceencaps=yes

# Connection for KABC airport
conn kabc_vpn
    type=tunnel
    auto=start
    keyexchange=ikev2
    ike=aes256gcm128-sha256-modp2048!
    esp=aes256gcm128-sha256-modp2048!
    left=%defaultroute
    leftid=@vpn.aviationwx.org
    leftsubnet=0.0.0.0/0
    leftauth=psk
    right=%any
    rightid=@kabc.remote
    rightsubnet=10.0.1.0/24
    rightauth=psk
    dpdaction=restart
    dpddelay=30s
    dpdtimeout=120s
    rekey=yes
    reauth=yes
    fragmentation=yes
    forceencaps=yes

# ... more connections ...
```

### ipsec.secrets (Generated by VPN Manager)

```
# IPsec secrets
# Auto-generated from airports.json
# PSKs loaded from environment variables

: PSK "${VPN_PSK_KSPB}"
: PSK "${VPN_PSK_KABC}"
# ... more PSKs ...
```

## VPN Manager Service (Python Example)

### vpn-manager.py

```python
#!/usr/bin/env python3
"""
VPN Manager Service
Manages IPsec VPN connections based on airports.json configuration
"""

import json
import os
import subprocess
import time
import logging
from pathlib import Path
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

CONFIG_PATH = os.getenv('CONFIG_PATH', '/var/www/html/config/airports.json')
IPSEC_CONF = '/etc/ipsec.d/ipsec.conf'
IPSEC_SECRETS = '/etc/ipsec.secrets'
HEALTH_CHECK_INTERVAL = 60  # seconds
RECONNECT_BACKOFF_BASE = 5  # seconds
MAX_BACKOFF = 300  # 5 minutes

class VPNManager:
    def __init__(self):
        self.connections: Dict[str, Dict] = {}
        self.connection_states: Dict[str, str] = {}  # 'up', 'down', 'connecting'
        self.last_health_check: Dict[str, float] = {}
        
    def load_config(self) -> Optional[Dict]:
        """Load airports.json configuration"""
        try:
            with open(CONFIG_PATH, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Failed to load config: {e}")
            return None
    
    def parse_vpn_configs(self, config: Dict) -> Dict[str, Dict]:
        """Extract VPN configurations from airports.json"""
        vpn_configs = {}
        
        for airport_id, airport in config.get('airports', {}).items():
            vpn = airport.get('vpn')
            if vpn and vpn.get('enabled'):
                connection_name = vpn.get('connection_name', f"{airport_id}_vpn")
                vpn_configs[connection_name] = {
                    'airport_id': airport_id,
                    'connection_name': connection_name,
                    'remote_subnet': vpn.get('remote_subnet'),
                    'psk': vpn.get('psk'),  # PSK stored directly in config
                    'ike_version': vpn.get('ike_version', '2'),
                    'encryption': vpn.get('encryption', 'aes256gcm128'),
                    'dh_group': vpn.get('dh_group', '14'),
                    'lifetime': vpn.get('lifetime', '3600'),
                }
        
        return vpn_configs
    
    def _get_psk_value(self, psk_value: str) -> Optional[str]:
        """Get PSK value directly from config (stored in airports.json)"""
        # PSKs are stored directly in airports.json, no env var lookup needed
        return psk_value if psk_value else None
    
    def generate_ipsec_config(self, vpn_configs: Dict[str, Dict]) -> str:
        """Generate strongSwan ipsec.conf from VPN configurations"""
        config_lines = [
            "# strongSwan IPsec configuration",
            "# Auto-generated from airports.json",
            "",
            "config setup",
            "    charondebug=\"ike 2, knl 2, cfg 2\"",
            "    uniqueids=never",
            "    strictcrlpolicy=no",
            "",
        ]
        
        for conn_name, config in vpn_configs.items():
            config_lines.extend([
                f"# Connection for {config['airport_id']} airport",
                f"conn {conn_name}",
                "    type=tunnel",
                "    auto=start",
                f"    keyexchange=ikev{config['ike_version']}",
                f"    ike={config['encryption']}-sha256-modp{config['dh_group']}!",
                f"    esp={config['encryption']}-sha256-modp{config['dh_group']}!",
                "    left=%defaultroute",
                "    leftid=@vpn.aviationwx.org",
                "    leftsubnet=0.0.0.0/0",
                "    leftauth=psk",
                "    right=%any",
                f"    rightid=@{config['airport_id']}.remote",
                f"    rightsubnet={config['remote_subnet']}",
                "    rightauth=psk",
                "    dpdaction=restart",
                "    dpddelay=30s",
                "    dpdtimeout=120s",
                "    rekey=yes",
                "    reauth=yes",
                "    fragmentation=yes",
                "    forceencaps=yes",
                "",
            ])
        
        return '\n'.join(config_lines)
    
    def generate_ipsec_secrets(self, vpn_configs: Dict[str, Dict]) -> str:
        """Generate strongSwan ipsec.secrets from VPN configurations"""
        secret_lines = [
            "# IPsec secrets",
            "# Auto-generated from airports.json",
            "# PSKs loaded from environment variables",
            "",
        ]
        
        for conn_name, config in vpn_configs.items():
            psk_value = config.get('psk')
            if psk_value:
                secret_lines.append(f": PSK \"{psk_value}\"")
            else:
                logger.warning(f"PSK not configured for {conn_name}")
        
        return '\n'.join(secret_lines)
    
    def write_config_files(self, ipsec_conf: str, ipsec_secrets: str):
        """Write generated configuration files"""
        try:
            with open(IPSEC_CONF, 'w') as f:
                f.write(ipsec_conf)
            with open(IPSEC_SECRETS, 'w') as f:
                f.write(ipsec_secrets)
            logger.info("Configuration files written successfully")
        except Exception as e:
            logger.error(f"Failed to write config files: {e}")
            raise
    
    def reload_ipsec_config(self):
        """Reload strongSwan configuration"""
        try:
            subprocess.run(['ipsec', 'reload'], check=True, capture_output=True)
            logger.info("IPsec configuration reloaded")
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to reload IPsec config: {e}")
            raise
    
    def check_connection_status(self, connection_name: str) -> str:
        """Check status of a VPN connection"""
        try:
            result = subprocess.run(
                ['ipsec', 'status', connection_name],
                capture_output=True,
                text=True,
                timeout=5
            )
            if 'ESTABLISHED' in result.stdout:
                return 'up'
            elif 'CONNECTING' in result.stdout:
                return 'connecting'
            else:
                return 'down'
        except Exception as e:
            logger.error(f"Failed to check status for {connection_name}: {e}")
            return 'down'
    
    def health_check_connection(self, connection_name: str, remote_subnet: str) -> bool:
        """Perform health check on VPN connection by pinging remote gateway"""
        # Extract gateway IP from subnet (first IP)
        gateway_ip = remote_subnet.split('/')[0].rsplit('.', 1)[0] + '.1'
        
        try:
            result = subprocess.run(
                ['ping', '-c', '1', '-W', '2', gateway_ip],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def restart_connection(self, connection_name: str):
        """Restart a VPN connection"""
        try:
            subprocess.run(['ipsec', 'down', connection_name], capture_output=True)
            time.sleep(2)
            subprocess.run(['ipsec', 'up', connection_name], check=True, capture_output=True)
            logger.info(f"Restarted connection: {connection_name}")
        except Exception as e:
            logger.error(f"Failed to restart {connection_name}: {e}")
    
    def monitor_connections(self):
        """Main monitoring loop"""
        while True:
            try:
                # Reload config to pick up changes
                config = self.load_config()
                if not config:
                    time.sleep(30)
                    continue
                
                vpn_configs = self.parse_vpn_configs(config)
                
                # Generate and write config files if changed
                ipsec_conf = self.generate_ipsec_config(vpn_configs)
                ipsec_secrets = self.generate_ipsec_secrets(vpn_configs)
                self.write_config_files(ipsec_conf, ipsec_secrets)
                self.reload_ipsec_config()
                
                # Update connection tracking
                self.connections = vpn_configs
                
                # Check each connection
                for conn_name, config in vpn_configs.items():
                    status = self.check_connection_status(conn_name)
                    self.connection_states[conn_name] = status
                    
                    # Health check if connection appears up
                    if status == 'up':
                        last_check = self.last_health_check.get(conn_name, 0)
                        if time.time() - last_check > HEALTH_CHECK_INTERVAL:
                            is_healthy = self.health_check_connection(
                                conn_name, 
                                config['remote_subnet']
                            )
                            self.last_health_check[conn_name] = time.time()
                            
                            if not is_healthy:
                                logger.warning(f"Health check failed for {conn_name}, restarting...")
                                self.restart_connection(conn_name)
                    elif status == 'down':
                        logger.warning(f"Connection {conn_name} is down, attempting restart...")
                        self.restart_connection(conn_name)
                
                time.sleep(30)  # Check every 30 seconds
                
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}")
                time.sleep(60)

if __name__ == '__main__':
    manager = VPNManager()
    manager.monitor_connections()
```

## Policy Routing Setup

### Routing Script (run in web container)

```bash
#!/bin/bash
# setup-vpn-routing.sh
# Sets up policy routing for VPN connections

# Load config
CONFIG_PATH=${CONFIG_PATH:-/var/www/html/config/airports.json}

# Parse airports.json and set up routing rules
# For each VPN-enabled airport, create routing rule for remote subnet

# Example for KSPB:
# ip route add 192.168.1.0/24 dev ipsec0
# ip rule add from all to 192.168.1.0/24 lookup 100
# ip route add default dev ipsec0 table 100

# This would be integrated into the VPN manager or a separate routing service
```

## PHP Integration Example

### lib/vpn-routing.php

```php
<?php
/**
 * VPN Routing Utilities
 * Handles VPN-aware routing for webcam fetches
 */

require_once __DIR__ . '/config.php';
require_once __DIR__ . '/logger.php';

/**
 * Check if a camera URL requires VPN routing
 * @param string $airportId Airport ID
 * @param array $cam Camera configuration
 * @return array|null VPN routing info or null if no VPN required
 */
function getVpnRoutingInfo($airportId, $cam) {
    $config = loadConfig();
    if (!$config || !isset($config['airports'][$airportId])) {
        return null;
    }
    
    $airport = $config['airports'][$airportId];
    $vpn = $airport['vpn'] ?? null;
    
    if (!$vpn || !($vpn['enabled'] ?? false)) {
        return null;
    }
    
    // Check if URL is a private IP (requires VPN)
    $url = $cam['url'] ?? '';
    if (preg_match('/(?:rtsp|http|https):\/\/(\d+\.\d+\.\d+\.\d+)/', $url, $matches)) {
        $ip = $matches[1];
        if (isPrivateIP($ip)) {
            return [
                'required' => true,
                'connection_name' => $vpn['connection_name'] ?? "{$airportId}_vpn",
                'remote_subnet' => $vpn['remote_subnet'] ?? null,
            ];
        }
    }
    
    return null;
}

/**
 * Check if IP address is private
 */
function isPrivateIP($ip) {
    $parts = explode('.', $ip);
    if (count($parts) !== 4) {
        return false;
    }
    
    // Private IP ranges:
    // 10.0.0.0/8
    // 172.16.0.0/12
    // 192.168.0.0/16
    // 127.0.0.0/8 (loopback)
    
    $first = (int)$parts[0];
    $second = (int)$parts[1];
    
    return ($first === 10) ||
           ($first === 172 && $second >= 16 && $second <= 31) ||
           ($first === 192 && $second === 168) ||
           ($first === 127);
}

/**
 * Check if VPN connection is up
 * @param string $connectionName VPN connection name
 * @return bool
 */
function isVpnConnectionUp($connectionName) {
    // Check via ipsec status command or status file
    $statusFile = "/var/run/ipsec-status/{$connectionName}";
    if (file_exists($statusFile)) {
        $status = trim(file_get_contents($statusFile));
        return $status === 'up';
    }
    
    // Fallback: try to ping remote gateway
    // This would require knowing the remote subnet from config
    return false;
}

/**
 * Verify VPN before fetching camera
 * @param string $airportId Airport ID
 * @param array $cam Camera configuration
 * @return bool True if VPN is up or not required
 */
function verifyVpnForCamera($airportId, $cam) {
    $vpnInfo = getVpnRoutingInfo($airportId, $cam);
    
    if (!$vpnInfo || !$vpnInfo['required']) {
        return true; // No VPN required
    }
    
    $isUp = isVpnConnectionUp($vpnInfo['connection_name']);
    
    if (!$isUp) {
        aviationwx_log('warning', 'VPN connection down for camera fetch', [
            'airport' => $airportId,
            'connection' => $vpnInfo['connection_name'],
            'camera_url' => $cam['url'] ?? 'unknown'
        ], 'app');
    }
    
    return $isUp;
}
```

## PSK Storage

### airports.json

PSKs are stored directly in `airports.json`:

```json
{
  "airports": {
    "kspb": {
      "vpn": {
        "enabled": true,
        "psk": "your-secure-psk-here"
      }
    }
  }
}
```

**Security Notes**:
- `airports.json` must never be committed to git
- Read-only mounts in Docker containers (sufficient protection)
- Deploy separately from codebase
- Rotate PSKs periodically
- Containers only need read access - no write permissions required

## Testing Examples

### Test VPN Connection Locally

```bash
# Start VPN server container
docker-compose up -d vpn-server

# Check IPsec status
docker exec aviationwx-vpn ipsec status

# View logs
docker logs -f aviationwx-vpn

# Test connection manually
docker exec aviationwx-vpn ipsec up kspb_vpn
```

### Mock VPN for Development

```python
# mock-vpn-server.py
# Simple mock VPN server for development testing

import socket
import threading

def mock_ipsec_server():
    # Listen on UDP 500 (IKE) and 4500 (NAT-T)
    # Accept connections and log them
    # Don't actually establish VPN, just simulate
    pass
```

## Remote Site Configuration Guide

### UniFi Gateway Configuration Steps

1. **Enable Dynamic DNS** (if needed):
   - Settings > Internet > Dynamic DNS
   - Configure DDNS provider
   - Note the hostname

2. **Configure Site-to-Site VPN**:
   - Settings > VPN > Site-to-Site VPN
   - Add new VPN
   - Type: Manual IPsec
   - Peer IP: [Production server static IP]
   - Local WAN IP: [Remote site public IP or DDNS hostname]
   - Remote Subnets: [Production server subnet if needed]
   - Pre-Shared Key: [Shared PSK]
   - IKE Version: 2
   - Encryption: AES-256-GCM
   - Hash: SHA-256
   - DH Group: 14

3. **Firewall Rules**:
   - Allow IPsec traffic (UDP 500, 4500)
   - Allow traffic to camera IPs from VPN

## Monitoring Script

### check-vpn-status.sh

```bash
#!/bin/bash
# Check VPN connection status for all airports

CONFIG_PATH=${CONFIG_PATH:-/var/www/html/config/airports.json}

# Parse config and check each VPN connection
# Output JSON status for monitoring

echo "{"
echo "  \"timestamp\": $(date +%s),"
echo "  \"connections\": ["

# Check each VPN connection
# ...

echo "  ]"
echo "}"
```

