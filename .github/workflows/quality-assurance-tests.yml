name: Quality Assurance Tests

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]
  workflow_dispatch: {} # Allow manual trigger

# Default permissions for all jobs in this workflow
permissions:
  contents: read
  actions: read
  pull-requests: read

jobs:
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    continue-on-error: true  # Don't block PR if these fail
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: apcu, gd, zip, curl, json, mbstring
          coverage: none
      
      - name: Install Composer dependencies
        run: |
          composer install --no-interaction --prefer-dist --optimize-autoloader --no-progress
      
      - name: Run Performance Tests
        run: |
          echo "Running performance tests..."
          vendor/bin/phpunit --testsuite Performance --testdox --log-junit performance-results.xml || [ $? -eq 1 ]
        continue-on-error: true
        env:
          CONFIG_PATH: tests/Fixtures/airports.json.test
      
      - name: Upload Performance Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-test-results
          path: performance-results.xml
          retention-days: 7
  
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    continue-on-error: true  # Don't block PR if these fail
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: apcu, gd, zip, curl, json, mbstring
          coverage: none
      
      - name: Install Composer dependencies
        run: |
          composer install --no-interaction --prefer-dist --optimize-autoloader --no-progress
      
      - name: Create test airports.json
        run: |
          # Create airports.json from example for Docker
          if [ ! -f airports.json ]; then
            cp airports.json.example airports.json
            echo "✓ Created airports.json from example"
          fi
      
      - name: Start Docker containers
        run: |
          # Start local instance for testing
          docker compose up -d
          sleep 15  # Wait for containers to be ready
          docker compose ps
      
      - name: Wait for health check
        run: |
          timeout=60
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if curl -f http://localhost:8080/health.php 2>/dev/null || curl -f http://localhost:8080/ 2>/dev/null; then
              echo "✓ Service is ready"
              exit 0
            fi
            sleep 2
            elapsed=$((elapsed + 2))
            echo "Waiting for service... ${elapsed}s"
          done
          echo "⚠ Service did not become ready in time"
          docker compose logs web
      
      - name: Run E2E Tests
        run: |
          echo "Running E2E tests with mocked APIs..."
          echo "Note: These tests use mocked API responses"
          vendor/bin/phpunit --testsuite E2E --testdox --log-junit e2e-results.xml || [ $? -eq 1 ]
        continue-on-error: true
        env:
          TEST_API_URL: http://localhost:8080
      
      - name: Cleanup
        if: always()
        run: |
          docker compose down
      
      - name: Upload E2E Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-test-results
          path: e2e-results.xml
          retention-days: 7
  
  smoke-tests:
    name: Smoke Tests - Local
    runs-on: ubuntu-latest
    continue-on-error: true  # Don't block PR if these fail
    if: github.event_name == 'pull_request' || github.event_name == 'push'  # Auto on PRs and pushes
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: apcu, gd, zip, curl, json, mbstring
          coverage: none
      
      - name: Install Composer dependencies
        run: |
          composer install --no-interaction --prefer-dist --optimize-autoloader --no-progress
      
      - name: Create test airports.json
        run: |
          # Create airports.json from example for Docker
          if [ ! -f airports.json ]; then
            cp airports.json.example airports.json
            echo "✓ Created airports.json from example"
          fi
      
      - name: Start Docker containers
        run: |
          docker compose up -d
          sleep 15
      
      - name: Run Smoke Tests (Local)
        run: |
          echo "Running smoke tests against local instance..."
          echo "Note: Docker container uses airports.json (mounted from host)"
          vendor/bin/phpunit --testsuite Smoke --testdox --log-junit smoke-results.xml || [ $? -eq 1 ]
        continue-on-error: true
        env:
          TEST_API_URL: http://localhost:8080
          # Note: CONFIG_PATH not set here - Docker container should use /var/www/html/airports.json
      
      - name: Cleanup
        if: always()
        run: |
          docker compose down
      
      - name: Upload Smoke Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-results
          path: smoke-results.xml
          retention-days: 7
  
  smoke-tests-production:
    name: Smoke Tests - Production (Manual Only)
    runs-on: ubuntu-latest
    continue-on-error: true
    if: github.event_name == 'workflow_dispatch'  # Only manual dispatch
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: apcu, gd, zip, curl, json, mbstring
          coverage: none
      
      - name: Install Composer dependencies
        run: |
          composer install --no-interaction --prefer-dist --optimize-autoloader --no-progress
      
      - name: Run Smoke Tests (Production)
        run: |
          echo "⚠️  WARNING: Running smoke tests against PRODUCTION"
          echo "Production URL: https://aviationwx.org"
          # Allow warnings but fail on actual test failures
          vendor/bin/phpunit --testsuite Smoke --testdox --log-junit smoke-prod-results.xml || [ $? -eq 1 ]
        continue-on-error: true
        env:
          TEST_PROD_URL: https://aviationwx.org
      
      - name: Upload Production Smoke Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-prod-test-results
          path: smoke-prod-results.xml
          retention-days: 7
  
  browser-tests:
    name: Browser Compatibility Tests
    runs-on: ubuntu-latest
    continue-on-error: true  # Don't block PR if these fail
    # Permissions for posting PR comments
    permissions:
      pull-requests: write
      contents: read
      issues: write
      actions: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: tests/Browser/package.json
      
      - name: Install Playwright dependencies
        working-directory: tests/Browser
        run: |
          npm install
          # Install only browsers we test in CI (Chromium for desktop + mobile)
          # This speeds up installation significantly
          npx playwright install --with-deps chromium
      
      - name: Create test airports.json
        run: |
          # Create airports.json from example for Docker
          if [ ! -f airports.json ]; then
            cp airports.json.example airports.json
            echo "✓ Created airports.json from example"
          fi
      
      - name: Start Docker containers
        run: |
          docker compose up -d
          sleep 15
          docker compose ps
      
      - name: Wait for service to be ready
        run: |
          timeout=60
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if curl -f http://localhost:8080/ 2>/dev/null; then
              echo "✓ Service is ready"
              exit 0
            fi
            sleep 2
            elapsed=$((elapsed + 2))
          done
          echo "⚠ Service did not become ready"
          docker compose logs web
      
      - name: Run Browser Tests
        working-directory: tests/Browser
        run: |
          # Run browser tests - exit code handling for Playwright
          npx playwright test || [ $? -eq 1 ]
        continue-on-error: true
        env:
          TEST_BASE_URL: http://localhost:8080
      
      - name: Upload Playwright Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: tests/Browser/playwright-report/
          retention-days: 7
      
      - name: Upload Playwright Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-results
          path: tests/Browser/playwright-results.json
          retention-days: 7
      
      - name: Upload Screenshots
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-screenshots
          path: tests/Browser/test-results/**/*.png
          if-no-files-found: ignore
          retention-days: 7
      
      - name: Download all test results for summary
        if: always()
        uses: actions/download-artifact@v4
        with:
          pattern: '*-test-results*'
          merge-multiple: true
          path: test-results
          if-no-files-found: ignore
      
      - name: Generate and Post Test Summary
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Parse browser test results
            const browserResults = {
              status: 'unknown',
              total: 0,
              passed: 0,
              failed: 0,
              skipped: 0
            };
            
            try {
              if (fs.existsSync('tests/Browser/playwright-results.json')) {
                const playwrightData = JSON.parse(fs.readFileSync('tests/Browser/playwright-results.json', 'utf8'));
                browserResults.total = playwrightData.stats?.total || 0;
                browserResults.passed = browserResults.total - (playwrightData.stats?.failures || 0) - (playwrightData.stats?.skipped || 0);
                browserResults.failed = playwrightData.stats?.failures || 0;
                browserResults.skipped = playwrightData.stats?.skipped || 0;
                browserResults.status = browserResults.failed === 0 ? (browserResults.skipped > 0 ? 'passed-with-skipped' : 'passed') : 'failed';
                console.log('Browser test results:', browserResults);
              } else {
                console.log('Browser test results file not found at tests/Browser/playwright-results.json');
              }
            } catch (e) {
              console.log('Error parsing browser test results:', e.message);
            }
            
            // Parse other test results
            const parseJUnitXML = (filePath) => {
              try {
                if (fs.existsSync(filePath)) {
                  const content = fs.readFileSync(filePath, 'utf8');
                  const testsMatch = content.match(/tests="(\d+)"/);
                  const failuresMatch = content.match(/failures="(\d+)"/);
                  const skippedMatch = content.match(/skipped="(\d+)"/);
                  return {
                    total: testsMatch ? parseInt(testsMatch[1]) : 0,
                    failed: failuresMatch ? parseInt(failuresMatch[1]) : 0,
                    skipped: skippedMatch ? parseInt(skippedMatch[1]) : 0,
                    status: failuresMatch && parseInt(failuresMatch[1]) === 0 ? 'passed' : 'failed'
                  };
                }
              } catch (e) {
                console.log(`Error parsing ${filePath}:`, e.message);
              }
              return { total: 0, failed: 0, skipped: 0, status: 'unknown' };
            };
            
            const performanceResults = parseJUnitXML('test-results/performance-results.xml');
            const e2eResults = parseJUnitXML('test-results/e2e-results.xml');
            const smokeResults = parseJUnitXML('test-results/smoke-results.xml');
            
            // Get status of blocking test workflows
            const getBlockingTestStatus = async () => {
              try {
                const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  event: 'pull_request',
                  per_page: 100
                });
                
                const prNumber = context.issue.number;
                const testRun = runs.workflow_runs.find(run => 
                  run.name === 'Test and Lint' && 
                  run.pull_requests?.some(pr => pr.number === prNumber)
                );
                
                const prChecksRun = runs.workflow_runs.find(run => 
                  run.name === 'PR Quality Gates' && 
                  run.pull_requests?.some(pr => pr.number === prNumber)
                );
                
                const testStatus = testRun ? 
                  (testRun.conclusion === 'success' ? '✅ Passed' : 
                   testRun.conclusion === 'failure' ? '❌ Failed' : 
                   testRun.status === 'in_progress' ? '🔄 In Progress' : '⏸️ Not Started') : '⏭️ Not Started';
                
                const prChecksStatus = prChecksRun ? 
                  (prChecksRun.conclusion === 'success' ? '✅ Passed' : 
                   prChecksRun.conclusion === 'failure' ? '❌ Failed' : 
                   prChecksRun.status === 'in_progress' ? '🔄 In Progress' : '⏸️ Not Started') : '⏭️ Not Started';
                
                return { testStatus, prChecksStatus, testRunId: testRun?.id, prChecksRunId: prChecksRun?.id };
              } catch (e) {
                console.log('Error checking blocking test status:', e.message);
                return { testStatus: '❓ Unknown', prChecksStatus: '❓ Unknown' };
              }
            };
            
            const blockingStatus = await getBlockingTestStatus();
            
            // Find representative screenshots (mobile and desktop)
            let mobileScreenshot = null;
            let desktopScreenshot = null;
            const screenshotsDir = 'tests/Browser/test-results';
            
            console.log('Looking for screenshots in:', screenshotsDir);
            console.log('Directory exists:', fs.existsSync(screenshotsDir));
            
            // Helper function to recursively find screenshots
            const findScreenshots = (dir) => {
              try {
                if (!fs.existsSync(dir)) {
                  console.log(`Directory does not exist: ${dir}`);
                  return;
                }
                console.log(`Scanning directory: ${dir}`);
                const entries = fs.readdirSync(dir, { withFileTypes: true });
                for (const entry of entries) {
                  const fullPath = path.join(dir, entry.name);
                  console.log(`Found entry: ${entry.name} (${entry.isDirectory() ? 'dir' : 'file'})`);
                  if (entry.isDirectory()) {
                    findScreenshots(fullPath);
                  } else if (entry.isFile() && entry.name.endsWith('.png')) {
                    console.log(`Found PNG: ${fullPath}`);
                    // Check for mobile screenshot
                    if ((entry.name.toLowerCase().includes('mobile') || 
                         fullPath.toLowerCase().includes('mobile') ||
                         entry.name.toLowerCase().includes('pixel')) && !mobileScreenshot) {
                      mobileScreenshot = fullPath;
                      console.log(`Set mobile screenshot: ${mobileScreenshot}`);
                    } 
                    // Check for desktop screenshot (chromium, desktop, or not mobile/tablet)
                    else if ((entry.name.toLowerCase().includes('chromium') || 
                             entry.name.toLowerCase().includes('desktop') ||
                             entry.name.toLowerCase().includes('screenshot') ||
                             (!entry.name.toLowerCase().includes('mobile') && 
                              !entry.name.toLowerCase().includes('tablet') && 
                              !fullPath.toLowerCase().includes('mobile') && 
                              !fullPath.toLowerCase().includes('tablet'))) && !desktopScreenshot) {
                      desktopScreenshot = fullPath;
                      console.log(`Set desktop screenshot: ${desktopScreenshot}`);
                    }
                  }
                }
              } catch (e) {
                console.log('Error scanning directory:', dir, e.message);
              }
            };
            
            findScreenshots(screenshotsDir);
            
            console.log('Mobile screenshot found:', mobileScreenshot);
            console.log('Desktop screenshot found:', desktopScreenshot);
            
            // Determine if tests passed or failed
            const browserTestsPassed = browserResults.status === 'passed' || browserResults.status === 'passed-with-skipped';
            const hasBrowserTestFailures = browserResults.failed > 0;
            
            // Find failure screenshots (from test failures)
            let failureScreenshots = [];
            const findFailureScreenshots = (dir) => {
              try {
                if (!fs.existsSync(dir)) return;
                const entries = fs.readdirSync(dir, { withFileTypes: true });
                for (const entry of entries) {
                  const fullPath = path.join(dir, entry.name);
                  if (entry.isDirectory()) {
                    findFailureScreenshots(fullPath);
                  } else if (entry.isFile() && entry.name.endsWith('.png')) {
                    // Failure screenshots are typically in subdirectories with test names
                    // or have "failed" in the path
                    const pathLower = fullPath.toLowerCase();
                    if (pathLower.includes('failed') || 
                        pathLower.includes('error') ||
                        (fullPath.includes('test-results') && fullPath.split(path.sep).length > 3)) {
                      failureScreenshots.push(fullPath);
                    }
                  }
                }
              } catch (e) {
                console.log('Error finding failure screenshots:', e.message);
              }
            };
            
            findFailureScreenshots(screenshotsDir);
            console.log('Failure screenshots found:', failureScreenshots.length);
            
            // Convert screenshots to base64 for embedding
            const encodeScreenshot = (filePath) => {
              try {
                if (fs.existsSync(filePath)) {
                  const imageBuffer = fs.readFileSync(filePath);
                  const base64 = imageBuffer.toString('base64');
                  const ext = path.extname(filePath).toLowerCase().slice(1) || 'png';
                  const mimeType = ext === 'png' ? 'image/png' : 'image/jpeg';
                  return `data:${mimeType};base64,${base64}`;
                }
              } catch (e) {
                console.log(`Error encoding screenshot ${filePath}:`, e.message);
              }
              return null;
            };
            
            // Build screenshot section - prioritize working website or failure screenshots
            let screenshotSection = '';
            
            if (browserTestsPassed && (mobileScreenshot || desktopScreenshot)) {
              // Tests passed - show working website screenshot
              screenshotSection = '\n\n### ✅ Working Website Screenshot\n\n';
              screenshotSection += 'All browser tests passed! Here\'s a screenshot of the working website:\n\n';
              
              // Prefer desktop screenshot for "working website" highlight
              if (desktopScreenshot) {
                const desktopBase64 = encodeScreenshot(desktopScreenshot);
                if (desktopBase64) {
                  screenshotSection += `<img src="${desktopBase64}" alt="Working Website - Desktop View" width="800" style="max-width: 100%; border: 2px solid #28a745; border-radius: 4px;" />\n\n`;
                }
              } else if (mobileScreenshot) {
                const mobileBase64 = encodeScreenshot(mobileScreenshot);
                if (mobileBase64) {
                  screenshotSection += `<img src="${mobileBase64}" alt="Working Website - Mobile View" width="400" style="max-width: 100%; border: 2px solid #28a745; border-radius: 4px;" />\n\n`;
                }
              }
              
              screenshotSection += '> ✅ All browser tests passed successfully!\n\n';
              screenshotSection += '> 💡 Full-size screenshots are available in [workflow artifacts](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/actions/runs/' + context.runId + ')\n';
            } else if (hasBrowserTestFailures && failureScreenshots.length > 0) {
              // Tests failed - show failure screenshots only
              screenshotSection = '\n\n### ⚠️ Test Failure Screenshots\n\n';
              screenshotSection += `${failureScreenshots.length} failure screenshot(s) found:\n\n`;
              
              // Limit to first 3 failure screenshots to avoid huge comments
              const screenshotsToShow = failureScreenshots.slice(0, 3);
              for (const failureScreenshot of screenshotsToShow) {
                const base64 = encodeScreenshot(failureScreenshot);
                if (base64) {
                  const screenshotName = path.basename(failureScreenshot);
                  screenshotSection += `<details>\n<summary><strong>🔴 ${screenshotName}</strong></summary>\n\n`;
                  screenshotSection += `<img src="${base64}" alt="Test Failure Screenshot: ${screenshotName}" width="600" style="max-width: 100%; border: 2px solid #dc3545; border-radius: 4px;" />\n\n`;
                  screenshotSection += '</details>\n\n';
                }
              }
              
              if (failureScreenshots.length > 3) {
                screenshotSection += `> *Showing first 3 of ${failureScreenshots.length} failure screenshots. View all in [workflow artifacts](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}).*\n\n`;
              }
              
              screenshotSection += '> 💡 All failure screenshots are available in [workflow artifacts](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/actions/runs/' + context.runId + ')\n';
            } else if (!browserTestsPassed && (mobileScreenshot || desktopScreenshot)) {
              // Tests failed but no specific failure screenshots - show any available screenshots
              screenshotSection = '\n\n### ⚠️ Browser Test Results\n\n';
              
              if (desktopScreenshot) {
                const desktopBase64 = encodeScreenshot(desktopScreenshot);
                if (desktopBase64) {
                  screenshotSection += `<img src="${desktopBase64}" alt="Browser Test Screenshot" width="600" style="max-width: 100%;" />\n\n`;
                }
              } else if (mobileScreenshot) {
                const mobileBase64 = encodeScreenshot(mobileScreenshot);
                if (mobileBase64) {
                  screenshotSection += `<img src="${mobileBase64}" alt="Browser Test Screenshot" width="400" style="max-width: 100%;" />\n\n`;
                }
              }
              
              screenshotSection += '> 💡 Screenshots are available in [workflow artifacts](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/actions/runs/' + context.runId + ')\n';
            } else {
              screenshotSection = '\n\n> ⚠️ No screenshots found. Check test-results directory for screenshot files.';
              // List what files we found
              try {
                if (fs.existsSync(screenshotsDir)) {
                  const listDir = (dir, depth = 0) => {
                    if (depth > 3) return '';
                    const entries = fs.readdirSync(dir, { withFileTypes: true });
                    return entries.map(entry => {
                      const fullPath = path.join(dir, entry.name);
                      if (entry.isDirectory()) {
                        return `  ${'  '.repeat(depth)}📁 ${entry.name}/\n${listDir(fullPath, depth + 1)}`;
                      } else {
                        return `  ${'  '.repeat(depth)}📄 ${entry.name}\n`;
                      }
                    }).join('');
                  };
                  const dirListing = listDir(screenshotsDir);
                  if (dirListing) {
                    screenshotSection += '\n\n**Files found in test-results:**\n```\n' + dirListing + '```';
                  }
                }
              } catch (e) {
                console.log('Error listing directory:', e.message);
              }
            }
            
            const comment = `## 📊 Complete Test Results Summary
            
            This summary includes results from **all test suites** (blocking and non-blocking).
            
            ### 🔒 Blocking Tests (Must Pass for Merge)
            
            | Test Suite | Status | Details |
            |------------|--------|---------|
            | **Test and Lint** (Unit, Integration, Critical Safety) | ${blockingStatus.testStatus} | ${blockingStatus.testRunId ? `[View workflow run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${blockingStatus.testRunId})` : 'Not available'} |
            | **PR Quality Gates** (All Tests, Security, Validation) | ${blockingStatus.prChecksStatus} | ${blockingStatus.prChecksRunId ? `[View workflow run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${blockingStatus.prChecksRunId})` : 'Not available'} |
            
            > ⚠️ **Note:** Blocking tests must pass before PR can be merged.
            
            ### 📈 Quality Assurance Tests
            
            These tests provide quality assurance but do **not block PR merges**.
            
            | Test Suite | Status | Details |
            |------------|--------|---------|
            | **Performance Tests** | ${performanceResults.status === 'passed' ? '✅ Passed' : performanceResults.status === 'failed' ? '⚠️ Failed' : '⏭️ Skipped'} | ${performanceResults.total > 0 ? `${performanceResults.total} tests (${performanceResults.failed} failed, ${performanceResults.skipped} skipped)` : 'No results'} |
            | **E2E Tests** | ${e2eResults.status === 'passed' ? '✅ Passed' : e2eResults.status === 'failed' ? '⚠️ Failed' : '⏭️ Skipped'} | ${e2eResults.total > 0 ? `${e2eResults.total} tests (${e2eResults.failed} failed, ${e2eResults.skipped} skipped)` : 'No results'} |
            | **Smoke Tests** | ${smokeResults.status === 'passed' ? '✅ Passed' : smokeResults.status === 'failed' ? '⚠️ Failed' : '⏭️ Skipped'} | ${smokeResults.total > 0 ? `${smokeResults.total} tests (${smokeResults.failed} failed, ${smokeResults.skipped} skipped)` : 'No results'} |
            | **Browser Tests** | ${browserResults.status === 'passed' || browserResults.status === 'passed-with-skipped' ? '✅ Passed' : browserResults.status === 'failed' ? '⚠️ Failed' : '⏭️ Skipped'} | ${browserResults.total > 0 ? `${browserResults.total} tests (${browserResults.passed} passed, ${browserResults.failed} failed, ${browserResults.skipped} skipped)` : 'No results'} |
            ${screenshotSection}
            📦 **Test artifacts** are available in the workflow run artifacts section.
            
            💡 **Note:** Quality assurance tests provide quality assurance. Review failures but they won't prevent merge.`;
            
            console.log('Posting comment to PR #' + context.issue.number);
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            console.log('Comment posted successfully');
      
      - name: Cleanup
        if: always()
        run: |
          docker compose down
