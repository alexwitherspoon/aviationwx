name: Deploy to Production

on:
  workflow_run:
    workflows: ["Test and Lint"]
    types:
      - completed
    branches: [ "main" ]
  workflow_dispatch: {} # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only runs after test workflow completes successfully (or manual dispatch)
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # When triggered by workflow_run, checkout the commit from that workflow
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Sync repository to server
        run: |
          rsync -az --delete --exclude '.git' --exclude 'cache' ./ ${{ secrets.USER }}@${{ secrets.HOST }}:~/aviationwx/

      - name: Ensure cache directories exist
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Create cache directories with permissions for www-data container user (UID 33)
          sudo mkdir -p cache/webcams
          # Use 777 for cache directory (acceptable for cache, no sensitive data)
          # Or alternatively: sudo chown -R 33:33 cache (www-data user)
          sudo chmod -R 777 cache
          # Ensure parent cache directory also has correct permissions
          sudo chmod 777 cache || true
          # Ensure host log directory exists for bind-mount and rotation
          sudo mkdir -p /var/log/aviationwx
          sudo chown root:root /var/log/aviationwx
          sudo chmod 755 /var/log/aviationwx
          EOF

      - name: Deploy via Docker Compose
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          docker compose -f docker-compose.prod.yml up -d --build
          docker system prune -f
          EOF

      - name: Ensure app log directory and file
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Create log file on host (bind-mounted into container)
          sudo touch /var/log/aviationwx/app.log
          sudo chown root:adm /var/log/aviationwx/app.log || true
          sudo chmod 640 /var/log/aviationwx/app.log || true
          # Create logrotate rule on host for app log
          sudo tee /etc/logrotate.d/aviationwx > /dev/null <<'LR'
/var/log/aviationwx/app.log {
    size 100M
    rotate 50
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
}
LR
          # Force a logrotate config test (dry-run)
          if command -v logrotate >/dev/null 2>&1; then sudo logrotate -d /etc/logrotate.conf || true; fi
          EOF

      - name: Reload Nginx inside container
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Attempt a graceful reload; if container not ready, start or restart it
          if docker compose -f docker-compose.prod.yml ps nginx | grep -q Up; then
            docker compose -f docker-compose.prod.yml exec -T nginx nginx -s reload || docker compose -f docker-compose.prod.yml up -d nginx
          else
            docker compose -f docker-compose.prod.yml up -d nginx
          fi
          EOF
      
      - name: Post-deployment health check
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          
          echo "Running post-deployment health checks..."
          
          # Wait for containers to be ready (give them time to start)
          echo "Waiting for containers to start..."
          sleep 8
          
          # Check if containers are running (check both services explicitly)
          CONTAINER_STATUS=$(docker compose -f docker-compose.prod.yml ps --format json 2>/dev/null || docker compose -f docker-compose.prod.yml ps)
          
          # Count running containers (both web and nginx should be up)
          RUNNING_COUNT=$(docker compose -f docker-compose.prod.yml ps --status running --format json 2>/dev/null | grep -c '"State":"running"' || docker compose -f docker-compose.prod.yml ps | grep -c "Up" || echo "0")
          
          # Check that we have at least the web container (nginx is optional but should be running too)
          if [ "$RUNNING_COUNT" -lt "1" ]; then
            echo "❌ Containers are not running"
            echo "Container status:"
            docker compose -f docker-compose.prod.yml ps
            echo ""
            echo "Recent logs:"
            docker compose -f docker-compose.prod.yml logs --tail=30
            exit 1
          fi
          
          echo "✓ Containers are running (${RUNNING_COUNT} container(s) up)"
          
          # Wait for Apache to be fully ready
          echo "Waiting for services to be ready..."
          sleep 10
          
          # Check if web container is responding (from inside container via exec)
          # This is more reliable than checking from host since Apache might have Host header issues
          echo "Testing web container from inside..."
          if ! docker compose -f docker-compose.prod.yml exec -T web curl -f -s --max-time 5 http://localhost/ > /dev/null 2>&1; then
            echo "❌ Web container is not responding (internal check failed)"
            echo "Checking container logs..."
            docker compose -f docker-compose.prod.yml logs web | tail -50
            echo "Checking container status..."
            docker compose -f docker-compose.prod.yml ps
            exit 1
          fi
          
          echo "✓ Web container is responding (internal check passed)"
          
          # Also check from host port (this might fail if Apache has Host header restrictions)
          APP_PORT=${APP_PORT:-8080}
          echo "Testing web container from host on port ${APP_PORT}..."
          if curl -f -s --max-time 5 http://127.0.0.1:${APP_PORT}/ > /dev/null 2>&1; then
            echo "✓ Web container is also responding from host on port ${APP_PORT}"
          else
            echo "⚠️  Web container not accessible from host (but internal check passed - this may be expected)"
            echo "This is OK if Nginx reverse proxy is handling external requests"
          fi
          
          # Check if diagnostics page loads (optional check)
          if ! curl -f -s --max-time 5 http://127.0.0.1:${APP_PORT}/diagnostics.php > /dev/null 2>&1; then
            echo "⚠️  Diagnostics page not accessible (may be expected)"
          else
            echo "✓ Diagnostics page accessible"
          fi
          
          # Check if config-utils.php exists
          if ! docker compose -f docker-compose.prod.yml exec -T web test -f /var/www/html/config-utils.php; then
            echo "❌ config-utils.php not found in container"
            exit 1
          fi
          
          echo "✓ config-utils.php present"
          
          # Check if rate-limit.php exists
          if ! docker compose -f docker-compose.prod.yml exec -T web test -f /var/www/html/rate-limit.php; then
            echo "❌ rate-limit.php not found in container"
            exit 1
          fi
          
          echo "✓ rate-limit.php present"
          
          # Check APCu extension
          if ! docker compose -f docker-compose.prod.yml exec -T web php -m | grep -q apcu; then
            echo "⚠️  APCu extension not loaded (rate limiting will be disabled)"
          else
            echo "✓ APCu extension loaded"
          fi
          
          echo "✅ All health checks passed"
          
          # Test webcam endpoints (smoke test)
          echo "Testing webcam endpoints..."
          # Test JPG endpoint for sample airport (assuming kspb exists)
          if curl -f -s --max-time 10 "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=jpg" > /tmp/webcam_test.jpg 2>/dev/null; then
            SIZE=$(stat -f%z /tmp/webcam_test.jpg 2>/dev/null || stat -c%s /tmp/webcam_test.jpg 2>/dev/null || echo "0")
            CTYPE=$(curl -sI "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=jpg" 2>/dev/null | grep -i 'content-type' | cut -d' ' -f2 | tr -d '\r' || echo "")
            if [ "$SIZE" -gt "0" ] && echo "$CTYPE" | grep -qi "image/jpeg"; then
              echo "✓ Webcam JPG endpoint working (size: ${SIZE} bytes, type: ${CTYPE})"
              rm -f /tmp/webcam_test.jpg
            else
              echo "⚠️  Webcam JPG endpoint returned invalid response (size: ${SIZE}, type: ${CTYPE})"
            fi
          else
            echo "⚠️  Webcam JPG endpoint not accessible (may be expected if no webcams configured)"
          fi
          
          # Test WEBP endpoint
          if curl -f -s --max-time 10 "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=webp" > /tmp/webcam_test.webp 2>/dev/null; then
            SIZE=$(stat -f%z /tmp/webcam_test.webp 2>/dev/null || stat -c%s /tmp/webcam_test.webp 2>/dev/null || echo "0")
            CTYPE=$(curl -sI "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=webp" 2>/dev/null | grep -i 'content-type' | cut -d' ' -f2 | tr -d '\r' || echo "")
            if [ "$SIZE" -gt "0" ] && echo "$CTYPE" | grep -qi "image/webp"; then
              echo "✓ Webcam WEBP endpoint working (size: ${SIZE} bytes, type: ${CTYPE})"
              rm -f /tmp/webcam_test.webp
            else
              echo "⚠️  Webcam WEBP endpoint returned invalid response (size: ${SIZE}, type: ${CTYPE})"
            fi
          else
            echo "ℹ️  Webcam WEBP endpoint not accessible (may be expected if WEBP not generated yet)"
          fi
          
          EOF

